#!/usr/bin/python3

import matplotlib.pyplot as plt
import numpy as np
import math
import random
from scipy import misc

def fct(x,y):
	return (1 - x)**2 + 100 * (y - x**2)**2

def partial_derivative(fct, var=0, point=[]):
	args = point[:]
	def wraps(x):
		args[var] = x
		return fct(*args)
	return misc.derivative(wraps, point[var], dx = 1e-6)

if __name__ == '__main__':
  # Rosenbrock function
  x = np.arange(-2.2, 2.2, 0.1)
  y = np.arange(-0.5, 3.0, 0.1)
  xx,yy = np.meshgrid(x,y)
  f = fct(xx,yy)
  h = plt.contourf(x,y,f)

  # initial conditions
  alpha = 0.0001
  eps = 0.0001
  eps_n = 2 * eps

  # first iteration
  x_0 = random.uniform(0.0, 2.0)
  y_0 = random.uniform(0.0, 2.0)
  tmp_z = fct(x_0,y_0)
  print(x_0,y_0,tmp_z)
  plt.scatter(x_0,y_0)

  # gradient descent
  while eps_n > eps:
    x_0 = x_0 - alpha * partial_derivative(fct, 0, [x_0,y_0])
    y_0 = y_0 - alpha * partial_derivative(fct, 1, [x_0,y_0])
    z = fct(x_0,y_0)
    eps_n = abs(tmp_z - z)
    tmp_z = z
    plt.scatter(x_0, y_0)

  print(x_0,y_0,z)
  plt.show()
